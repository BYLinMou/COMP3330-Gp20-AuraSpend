/**
 * Pet Phrases Configuration
 * Contains localized phrases for pet interactions
 */

export const PET_PHRASES = {
  en: [
    "Saving a bit today, freer tomorrow. ğŸ¾ğŸ’°",
    "Tiny savings, big peace. ğŸ›¡ï¸âœ¨",
    "Let your coins quietly grow. ğŸŒ±ğŸ’¸",
    "Smart saving brings dreams closer. ğŸğŸ’–",
    "Spend a little, save a little. âš–ï¸ğŸ±",
    "Small steps, big goals. âœ¨ğŸ“ˆ",
    "Will this still feel worth it later? ğŸ§ ğŸ’µ",
    "Each coin builds your freedom. ğŸ—ï¸ğŸŒˆ",
    "Less impulse, more purpose. ğŸ¯ğŸ’š",
    "Save now, stress less. ğŸ¶ğŸ“Š",
    "Even one coin counts. ğŸ¾ğŸ“ˆ",
    "Tracking money is selfâ€‘care. ğŸ¤—ğŸ’¸",
    "Progress beats perfection. ğŸŒ¤ï¸ğŸ“†",
    "Quiet savings, big upgrades. ğŸ•¹ï¸ğŸ’°",
    "Choose longâ€‘term joy, not impulse. ğŸ’–â³",
    "Cute goal, steady steps. ğŸ‰ğŸ¯",
    "Money is your tool, not your boss. ğŸ§©ğŸ‘‘",
    "Pause before you pay. â¸ï¸ğŸ†",
    "One â€˜noâ€™ powers your dreams. ğŸ™…â€â™‚ï¸ğŸŒŸ",
    "You and your wallet are a team. ğŸ¾ğŸ’¼",
    "One less snack, one more coin. ğŸªâ¡ï¸ğŸ’°",
    "Coins today, choices tomorrow. ğŸª™â¡ï¸ğŸ¯",
    "Youâ€™re quietly getting richer. ğŸ¤«ğŸ’¸",
    "Your savings grow while you rest. ğŸ˜´ğŸ“ˆ",
    "Think goal first, then buy. ğŸ¯ğŸ›’",
    "Budget first, shopping later. ğŸ“‹ğŸ›ï¸",
    "A plan is the best discount. ğŸ§ ğŸ’°",
    "Tiny cuts, huge results. âœ‚ï¸ğŸ“Š",
    "Save for joy, not for fear. ğŸŒˆğŸ’µ",
    "A calm wallet, a calm mind. ğŸ˜ŒğŸ’¼",
    "Less stuff, more freedom. ğŸ“¦âŒğŸ—½",
    "Let patience grow your money. â³ğŸŒ±",
    "Track it to control it. ğŸ“ğŸ’¸",
    "Dream first, swipe later. ğŸŒŸğŸ’³",
    "Needs first, wants later. âœ…â¡ï¸âœ¨",
    "Your goals are cheering for you. ğŸ“£ğŸ¯",
    "Skip one impulse, win one step. ğŸƒâ€â™€ï¸ğŸ“ˆ",
    "Savings are your soft shield. ğŸ›¡ï¸ğŸ’š",
    "Treat each coin kindly. ğŸ¾ğŸª™",
    "Iâ€™m proud of every tiny effort. ğŸ¥¹ğŸ’°"
  ],
  zh: [
    "ä¸€ç‚¹ç‚¹å­˜ï¼Œæ˜å¤©æ›´è½»æ¾ã€‚ğŸ¾ğŸ’°",
    "å°å°å­˜æ¬¾ï¼Œå¤§å¤§å®‰å¿ƒã€‚ğŸ›¡ï¸âœ¨",
    "è®©é’±åƒæ ‘è‹—æ…¢æ…¢é•¿ã€‚ğŸŒ±ğŸ’¸",
    "èªæ˜å­˜é’±ï¼Œé è¿‘æ¢¦æƒ³ã€‚ğŸğŸ’–",
    "æƒ³èŠ±å°±èŠ±ï¼Œä¹Ÿåˆ«å¿˜å­˜ã€‚âš–ï¸ğŸ±",
    "å°æ­¥ä¼ï¼Œå¤§ç›®æ ‡ã€‚âœ¨ğŸ“ˆ",
    "ä¹°å‰æƒ³æƒ³ï¼Œå€¼ä¸å€¼ã€‚ğŸ§ ğŸ’µ",
    "ä½ åœ¨æ›¿æœªæ¥é“ºè·¯ã€‚ğŸ—ï¸ğŸŒˆ",
    "å°‘ç‚¹å†²åŠ¨ï¼Œå¤šç‚¹ç›®æ ‡ã€‚ğŸ¯ğŸ’š",
    "å¤šå­˜ä¸€ç‚¹ï¼Œå°‘çƒ¦ä¸€ç‚¹ã€‚ğŸ¶ğŸ“Š",
    "åªå­˜ä¸€ç‚¹ä¹Ÿå¾ˆæ£’ã€‚ğŸ¾ğŸ“ˆ",
    "è®°è´¦å­˜é’±ï¼Œæ˜¯ç§æ¸©æŸ”ã€‚ğŸ¤—ğŸ’¸",
    "ä¸æ±‚å®Œç¾ï¼Œåªæ±‚è¿›æ­¥ã€‚ğŸŒ¤ï¸ğŸ“†",
    "å®‰é™çš„å­˜æ¬¾åœ¨å‡çº§ä½ ã€‚ğŸ•¹ï¸ğŸ’°",
    "å…‹åˆ¶ä¸€ä¸‹ï¼Œå¤šç‚¹å¹¸ç¦ã€‚ğŸ’–â³",
    "å°ç›®æ ‡ï¼Œä¹Ÿè¯¥è¢«åº†ç¥ã€‚ğŸ‰ğŸ¯",
    "é’±æ˜¯å·¥å…·ï¼Œä¸æ˜¯ä¸»äººã€‚ğŸ§©ğŸ‘‘",
    "èŠ±å‰åœä¸€ä¸‹ï¼Œä½ å°±èµ¢ã€‚â¸ï¸ğŸ†",
    "å°‘ä¸€æ¬¡ä¹±ä¹°ï¼Œå¤šä¸€ç‚¹æ¢¦ã€‚ğŸ™…â€â™‚ï¸ğŸŒŸ",
    "ä½ å’Œé’±åŒ…ï¼Œæ˜¯å¥½æ­æ¡£ã€‚ğŸ¾ğŸ’¼",
    "å°‘ä¸€æ¯å¥¶èŒ¶ï¼Œå¤šä¸€å—å­˜æ¬¾ã€‚ğŸ§‹â¡ï¸ğŸ’°",
    "ä»Šå¤©å¤šä¸€å—ï¼Œæ˜å¤©å¤šé€‰æ‹©ã€‚ğŸª™â¡ï¸ğŸ¯",
    "ä½ åœ¨æ‚„æ‚„å˜å¯Œã€‚ğŸ¤«ğŸ’¸",
    "ç¡è§‰æ—¶ï¼Œé’±ä¹Ÿåœ¨é•¿ã€‚ğŸ˜´ğŸ“ˆ",
    "å…ˆæƒ³ç›®æ ‡ï¼Œå†æƒ³è´­ç‰©ã€‚ğŸ¯ğŸ›’",
    "å…ˆåšé¢„ç®—ï¼Œå†å»ä¹°å•ã€‚ğŸ“‹ğŸ›ï¸",
    "æœ€å¥½çš„ä¼˜æƒ æ˜¯æœ‰è®¡åˆ’ã€‚ğŸ§ ğŸ’°",
    "å°å°å‰Šå‡ï¼Œå¤§å¤§æˆæœã€‚âœ‚ï¸ğŸ“Š",
    "ä¸ºå¿«ä¹å­˜é’±ï¼Œä¸ä¸ºææƒ§ã€‚ğŸŒˆğŸ’µ",
    "é’±åŒ…å®‰ç¨³ï¼Œäººå°±å®‰å¿ƒã€‚ğŸ˜ŒğŸ’¼",
    "å°‘ç‚¹ä¸œè¥¿ï¼Œå¤šç‚¹è‡ªç”±ã€‚ğŸ“¦âŒğŸ—½",
    "è€å¿ƒä¸€ç‚¹ï¼Œé’±é•¿æ›´å¿«ã€‚â³ğŸŒ±",
    "è®°ä¸‹æ¥ï¼Œæ‰ç®¡å¾—ä½ã€‚ğŸ“ğŸ’¸",
    "å…ˆæƒ³æ¢¦æƒ³ï¼Œå†åˆ·å¡ã€‚ğŸŒŸğŸ’³",
    "å…ˆæ»¡è¶³éœ€è¦ï¼Œå†è€ƒè™‘æƒ³è¦ã€‚âœ…â¡ï¸âœ¨",
    "ä½ çš„ç›®æ ‡åœ¨ä¸ºä½ é¼“æŒã€‚ğŸ“£ğŸ¯",
    "å°‘ä¸€æ¬¡å†²åŠ¨ï¼Œå¤šä¸€æ­¥è¿›æ­¥ã€‚ğŸƒâ€â™€ï¸ğŸ“ˆ",
    "å­˜æ¬¾æ˜¯æŸ”è½¯çš„å°é“ ç”²ã€‚ğŸ›¡ï¸ğŸ’š",
    "æŠŠæ¯ä¸€å—éƒ½æ¸©æŸ”å¯¹å¾…ã€‚ğŸ¾ğŸª™",
    "æˆ‘çœŸçš„ä¸ºä½ çš„åŠªåŠ›éª„å‚²ã€‚ğŸ¥¹ğŸ’°"
  ]
};

/**
 * Get a random phrase in the specified language
 * Ensures the new phrase is different from the previous one
 */
export function getRandomPetPhrase(language: 'en' | 'zh', previousPhrase?: string): string {
  const phrases = PET_PHRASES[language];
  
  if (phrases.length === 0) {
    return "...";
  }
  
  if (phrases.length === 1) {
    return phrases[0];
  }
  
  let newPhrase;
  do {
    newPhrase = phrases[Math.floor(Math.random() * phrases.length)];
  } while (newPhrase === previousPhrase);
  
  return newPhrase;
}
